<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kart Telemetria - Dashboard Live MQTT</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow-x: hidden;
        }
        .header {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,255,136,0.3);
        }
        .header h1 { font-size: 24px; }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.2);
            padding: 8px 15px;
            border-radius: 20px;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
            animation: pulse 2s infinite;
        }
        .status-dot.connected {
            background: #00ff00;
            animation: none;
        }
        .status-subtext {
            font-size: 12px;
            color: #ccc;
            display: block;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 80px);
        }
        .main-panel {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .data-card {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #00ff88;
        }
        .data-card h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .data-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }
        .data-item:last-child { border-bottom: none; }
        .data-label { color: #aaa; }
        .data-value {
            color: #00ff88;
            font-weight: bold;
        }
        .lap-times-wrapper {
            margin-top: 12px;
        }
        .lap-times-wrapper .data-label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            text-transform: uppercase;
            color: #ccc;
            letter-spacing: 0.5px;
        }
        .lap-times {
            background: rgba(0, 0, 0, 0.35);
            border-radius: 8px;
            border: 1px solid #444;
            padding: 8px;
            max-height: 160px;
            overflow-y: auto;
            font-size: 14px;
        }
        .lap-times::-webkit-scrollbar {
            width: 6px;
        }
        .lap-times::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 3px;
        }
        .lap-times .lap-item {
            padding: 4px 6px;
            margin-bottom: 4px;
            border-radius: 4px;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .lap-times .lap-item:last-child {
            margin-bottom: 0;
        }
        .lap-times .lap-item.empty {
            background: transparent;
            color: #aaa;
            text-align: center;
            border: 1px dashed #444;
        }
        #map {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .temp-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .temp-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .temp-label { font-size: 12px; color: #aaa; margin-bottom: 5px; }
        .temp-value { font-size: 20px; color: #00ff88; font-weight: bold; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèéÔ∏è Kart Telemetria - Dashboard Live</h1>
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">DISCONNESSO</span>
            <span id="telemetryStatus" class="status-subtext">Telemetria non disponibile</span>
        </div>
    </div>

    <div class="container">
        <div class="main-panel">
            <div id="map"></div>
            <div class="data-card">
                <h3>üìç Posizione GPS</h3>
                <div class="data-item">
                    <span class="data-label">Latitudine:</span>
                    <span class="data-value" id="latitude">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Longitudine:</span>
                    <span class="data-value" id="longitude">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Velocit√†:</span>
                    <span class="data-value" id="speed">-- km/h</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Altitudine:</span>
                    <span class="data-value" id="altitude">-- m</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Satelliti:</span>
                    <span class="data-value" id="satellites">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Stato Tappeto:</span>
                    <span class="data-value" id="tappetoStatus">NON CREATO</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Coordinate Tappeto:</span>
                    <span class="data-value" id="tappetoCoords">0/10</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Centro Tappeto:</span>
                    <span class="data-value" id="tappetoCenter">--</span>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="data-card">
                <h3>üå°Ô∏è Temperature Gomme</h3>
                <div class="temp-grid">
                    <div class="temp-item">
                        <div class="temp-label">Anteriore Destra</div>
                        <div class="temp-value" id="tempAD">--¬∞C</div>
                    </div>
                    <div class="temp-item">
                        <div class="temp-label">Anteriore Sinistra</div>
                        <div class="temp-value" id="tempAX">--¬∞C</div>
                    </div>
                    <div class="temp-item">
                        <div class="temp-label">Posteriore Destra</div>
                        <div class="temp-value" id="tempPD">--¬∞C</div>
                    </div>
                    <div class="temp-item">
                        <div class="temp-label">Posteriore Sinistra</div>
                        <div class="temp-value" id="tempPX">--¬∞C</div>
                    </div>
                </div>
            </div>

            <div class="data-card">
                <h3>üî• Temperature Motore</h3>
                <div class="data-item">
                    <span class="data-label">Motore:</span>
                    <span class="data-value" id="tempMotore">--¬∞C</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Acqua:</span>
                    <span class="data-value" id="tempAcqua">--¬∞C</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Scarico:</span>
                    <span class="data-value" id="tempScarico">--¬∞C</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Ambiente:</span>
                    <span class="data-value" id="tempAmbiente">--¬∞C</span>
                </div>
            </div>

            <div class="data-card">
                <h3>‚è±Ô∏è Cronometro</h3>
                <div id="garaFinitaMessage" style="display:none; background: rgba(0,255,136,0.2); border: 2px solid #00ff88; border-radius: 8px; padding: 15px; margin-bottom: 15px; text-align: center;">
                    <div style="color: #00ff88; font-size: 1.5em; font-weight: bold; margin-bottom: 10px;">üèÅ GARA FINITA üèÅ</div>
                    <div style="color: #fff; font-size: 1.2em;">
                        <span style="color: #ffaa00;">Miglior Tempo:</span>
                        <span id="bestLapTimeDisplay" style="font-weight: bold; color: #00ff88;">00:00.000</span>
                    </div>
                </div>
                <div class="data-item">
                    <span class="data-label">Stato:</span>
                    <span class="data-value" id="cronometroStatus">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Tempo Giro:</span>
                    <span class="data-value" id="cronometroLapTime">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Ultimo Giro:</span>
                    <span class="data-value" id="lastLapTime">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Giri Completati:</span>
                    <span class="data-value" id="completedGiri">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Giri Target:</span>
                    <span class="data-value" id="targetGiri">--</span>
                </div>
                <div class="lap-times-wrapper">
                    <span class="data-label">Tempi giri</span>
                    <div class="lap-times" id="lapTimesList">
                        <div class="lap-item empty">Nessun giro completato</div>
                    </div>
                </div>
            </div>

            <div class="data-card">
                <h3>üìä IMU (Accelerometro/Giroscopio)</h3>
                <div class="data-item">
                    <span class="data-label">Accel X:</span>
                    <span class="data-value" id="lsm_ax">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Accel Y:</span>
                    <span class="data-value" id="lsm_ay">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Accel Z:</span>
                    <span class="data-value" id="lsm_az">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Gyro Z:</span>
                    <span class="data-value" id="lsm_gz">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Stato:</span>
                    <span class="data-value" id="lsm_stato">--</span>
                </div>
            </div>

            <div class="data-card">
                <h3>üìè Distanze</h3>
                <div class="data-item">
                    <span class="data-label">Distanza Giro:</span>
                    <span class="data-value" id="distanceLap">-- m</span>
                </div>
            </div>

            <div class="data-card" style="border-left-color: #ffaa00;">
                <h3>üîç Debug Connessione</h3>
                <div class="data-item">
                    <span class="data-label">Stato:</span>
                    <span class="data-value" id="debugStatus">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Ultimo Messaggio:</span>
                    <span class="data-value" id="debugLastMessage">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Topic:</span>
                    <span class="data-value" id="debugTopic">--</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Messaggi Ricevuti:</span>
                    <span class="data-value" id="debugMessageCount">0</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script>
        // Configurazione HiveMQ Cloud
        // HiveMQ Cloud WebSocket URL - Prova entrambe le varianti se una non funziona
        const MQTT_BROKER = 'wss://71f47778c3f94d9ea4aac7f92f89f948.s1.eu.hivemq.cloud:8884/mqtt';
        // Alternativa (senza /mqtt): 'wss://71f47778c3f94d9ea4aac7f92f89f948.s1.eu.hivemq.cloud:8884'
        const MQTT_USERNAME = 'angelo';
        const MQTT_PASSWORD = 'Es31101959@99';
        const MQTT_TOPIC_TELEMETRY = 'kart/telemetry';
        const MQTT_TOPIC_TELEMETRY_WILDCARD = 'kart/telemetry/+'; // Cattura anche kart/telemetry/{sessionName}
        const MQTT_TOPIC_GPS = 'kart/gps';

        // Inizializza mappa
        let map = L.map('map').setView([41.3083, 14.2667], 13); // Default: Italia centrale
        let kartMarker = null;
        let trackLine = [];
        let trackPolyline = null;
        let markerStartLatLng = null;
        let markerTargetLatLng = null;
        let markerAnimationId = null;
        
        // Cache per valori del tappeto (per evitare lampeggiare quando GPS oscilla)
        let cachedTappetoCreated = null;
        let cachedTappetoMode = null;
        let cachedTappetoCoordinates = null;
        let cachedTappetoCenterLat = null;
        let cachedTappetoCenterLng = null;
        
        // Cache per tutti gli altri valori (mantengono valore precedente se non arrivano nuovi dati)
        let cachedSpeed = null;
        let cachedAlt = null;
        let cachedSatellites = null;
        let cachedTempAD = null;
        let cachedTempAX = null;
        let cachedTempPD = null;
        let cachedTempPX = null;
        let cachedTempMotore = null;
        let cachedTempAcqua = null;
        let cachedTempScarico = null;
        let cachedTempAmbiente = null;
        let cachedLsmAx = null;
        let cachedLsmAy = null;
        let cachedLsmAz = null;
        let cachedLsmGz = null;
        let cachedLsmStato = null;
        let cachedDistanceLap = null;
        let cachedCronometroStatus = null;
        let cachedCronometroLapTime = null;
        let cachedCompletedGiri = null;
        let cachedTargetGiri = null;
        let cachedLapTimes = null;
        let cachedLastLapTime = null;
let markerAnimationStart = 0;
let markerAnimationDuration = 1000;
const LIVE_REFERENCE_SPEED = 40;   // km/h di riferimento
const LIVE_MIN_DURATION = 250;     // durata minima interpolazione (ms)
const LIVE_MAX_DURATION = 2000;    // durata massima interpolazione (ms)

        let mqttConnectedFlag = false;
        let lastTelemetryTime = 0;
        const TELEMETRY_TIMEOUT = 5000; // millisecondi

        L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
            attribution: '¬© Google',
            maxZoom: 20
        }).addTo(map);

        // Variabili per debug
        let messageCount = 0;
        let lastMessageTime = null;
        
        function updateDebugInfo(status, topic = null) {
            document.getElementById('debugStatus').textContent = status;
            if (topic) {
                document.getElementById('debugTopic').textContent = topic;
            }
            document.getElementById('debugMessageCount').textContent = messageCount;
            if (lastMessageTime) {
                const timeAgo = Math.floor((Date.now() - lastMessageTime) / 1000);
                document.getElementById('debugLastMessage').textContent = timeAgo + 's fa';
            }
        }
        
        // Connessione MQTT
        console.log('üîå Tentativo connessione a HiveMQ Cloud...');
        console.log('üìç Broker:', MQTT_BROKER);
        console.log('üë§ Username:', MQTT_USERNAME);
        console.log('üîë Password:', MQTT_PASSWORD ? '***' : 'NON IMPOSTATA');
        
        const clientId = 'dashboard_' + Math.random().toString(16).substr(2, 8);
        console.log('üÜî Client ID:', clientId);
        
        document.getElementById('statusText').textContent = 'CONNESSIONE...';
        updateDebugInfo('CONNESSIONE...');
        updateTelemetryStatus();
        
        const client = mqtt.connect(MQTT_BROKER, {
            clientId: clientId,
            username: MQTT_USERNAME,
            password: MQTT_PASSWORD,
            clean: true,
            reconnectPeriod: 5000,
            connectTimeout: 30 * 1000,
            keepalive: 60,
            protocolVersion: 4,
            protocolId: 'MQTT',
            rejectUnauthorized: false // Permetti certificati self-signed se necessario
        });

        client.on('connect', (packet) => {
            console.log('‚úÖ Connesso a HiveMQ Cloud!');
            console.log('üìä Packet:', packet);
            document.getElementById('statusDot').classList.add('connected');
            document.getElementById('statusText').textContent = 'CONNESSO';
            updateDebugInfo('CONNESSO');
            mqttConnectedFlag = true;
            lastTelemetryTime = 0;
            updateTelemetryStatus();
            
            // Aspetta un momento prima di sottoscriversi
            setTimeout(() => {
                console.log('üì° Sottoscrizione ai topic...');
                
                // Sottoscrivi con QoS 0 (pi√π compatibile)
                client.subscribe(MQTT_TOPIC_TELEMETRY, { qos: 0 }, (err, granted) => {
                    if (err) {
                        console.error('‚ùå Errore sottoscrizione telemetry:', err);
                    } else {
                        console.log('‚úÖ Sottoscritto a:', MQTT_TOPIC_TELEMETRY);
                        if (granted && granted[0] && granted[0].qos === 128) {
                            console.error('‚ùå SOTTOSCRIZIONE RIFIUTATA! Verifica autorizzazioni HiveMQ Cloud');
                        }
                    }
                });

                // Sottoscrivi anche al topic con sessione (es. kart/telemetry/NomePilota)
                client.subscribe(MQTT_TOPIC_TELEMETRY_WILDCARD, { qos: 0 }, (err, granted) => {
                    if (err) {
                        console.error('‚ùå Errore sottoscrizione telemetry wildcard:', err);
                    } else {
                        console.log('‚úÖ Sottoscritto a:', MQTT_TOPIC_TELEMETRY_WILDCARD);
                        if (granted && granted[0] && granted[0].qos === 128) {
                            console.error('‚ùå SOTTOSCRIZIONE WILDCARD RIFIUTATA! Verifica autorizzazioni HiveMQ Cloud');
                        }
                    }
                });
                
                client.subscribe(MQTT_TOPIC_GPS, { qos: 0 }, (err, granted) => {
                    if (err) {
                        console.error('‚ùå Errore sottoscrizione GPS:', err);
                    } else {
                        console.log('‚úÖ Sottoscritto a:', MQTT_TOPIC_GPS);
                    }
                });
            }, 500);
        });

        client.on('disconnect', (packet) => {
            console.log('‚ùå Disconnesso da HiveMQ Cloud');
            console.log('üìä Packet:', packet);
            document.getElementById('statusDot').classList.remove('connected');
            document.getElementById('statusText').textContent = 'DISCONNESSO';
            updateDebugInfo('DISCONNESSO');
            mqttConnectedFlag = false;
            updateTelemetryStatus();
        });

        client.on('error', (error) => {
            console.error('‚ùå Errore MQTT:', error);
            console.error('‚ùå Stack:', error.stack);
            const errorMsg = error.message || error.toString() || 'Errore sconosciuto';
            document.getElementById('statusText').textContent = 'ERRORE: ' + errorMsg;
            document.getElementById('statusDot').classList.remove('connected');
            updateDebugInfo('ERRORE: ' + errorMsg);
            mqttConnectedFlag = false;
            updateTelemetryStatus();
        });

        client.on('close', () => {
            console.log('üîå Connessione chiusa');
            document.getElementById('statusDot').classList.remove('connected');
            document.getElementById('statusText').textContent = 'CONNESSIONE CHIUSA';
            mqttConnectedFlag = false;
            updateTelemetryStatus();
        });

        client.on('offline', () => {
            console.log('‚ö†Ô∏è Client MQTT offline');
            document.getElementById('statusText').textContent = 'OFFLINE';
            document.getElementById('statusDot').classList.remove('connected');
            mqttConnectedFlag = false;
            updateTelemetryStatus();
        });

        client.on('reconnect', () => {
            console.log('üîÑ Tentativo riconnessione...');
            document.getElementById('statusText').textContent = 'RICONNESSIONE...';
        });

        client.on('end', () => {
            console.log('üîö Connessione terminata');
            document.getElementById('statusText').textContent = 'TERMINATA';
            mqttConnectedFlag = false;
            updateTelemetryStatus();
        });

        // Listener per TUTTI i messaggi (anche se sottoscrizione fallisce)
        client.on('message', (topic, message) => {
            try {
                messageCount++;
                lastMessageTime = Date.now();
                if (topic.includes('telemetry')) {
                    lastTelemetryTime = Date.now();
                }
                const messageStr = message.toString();
                console.log('üéâüéâüéâ MESSAGGIO RICEVUTO! üéâüéâüéâ');
                console.log('üì® Topic:', topic);
                console.log('üì¶ Payload length:', messageStr.length, 'caratteri');
                console.log('üì¶ Payload (primi 300 caratteri):', messageStr.substring(0, 300));
                updateDebugInfo('MESSAGGIO RICEVUTO', topic);
                updateTelemetryStatus();
                
                // Verifica se il topic √® uno di quelli che ci interessano
                if (topic.includes('telemetry') || topic.includes('gps') || topic.includes('kart')) {
                    console.log('‚úÖ Topic riconosciuto, parsing JSON...');
                    const data = JSON.parse(messageStr);
                    console.log('‚úÖ‚úÖ‚úÖ JSON parsato correttamente! ‚úÖ‚úÖ‚úÖ');
                    console.log('üìä Dati ricevuti:', Object.keys(data));
                    updateDashboard(data);
                } else {
                    console.log('‚ÑπÔ∏è Topic non riconosciuto, ignorato:', topic);
                }
            } catch (e) {
                console.error('‚ùå Errore parsing JSON:', e);
                console.error('‚ùå Messaggio ricevuto:', message.toString());
                updateDebugInfo('ERRORE PARSING JSON');
            }
        });
        
        setInterval(updateTelemetryStatus, 2000);

        // Listener aggiuntivo per debug - mostra TUTTI gli eventi MQTT
        client.on('packetsend', (packet) => {
            console.log('üì§ Pacchetto inviato:', packet.cmd);
        });
        
        client.on('packetreceive', (packet) => {
            console.log('üì• Pacchetto ricevuto:', packet.cmd);
            if (packet.cmd === 'publish') {
                console.log('üéâüéâüéâ PUBLISH RICEVUTO DAL BROKER! üéâüéâüéâ');
                console.log('   Topic:', packet.topic);
                console.log('   QoS:', packet.qos);
                console.log('   Payload type:', typeof packet.payload);
                console.log('   Payload length:', packet.payload ? packet.payload.length : 0);
                if (packet.payload) {
                    const payloadStr = packet.payload.toString();
                    console.log('   Payload (primi 200 char):', payloadStr.substring(0, 200));
                }
            }
            if (packet.cmd === 'suback') {
                console.log('üì• SUBACK ricevuto');
                console.log('   Packet completo:', packet);
                console.log('   Granted:', packet.granted);
                
                if (packet.granted && Array.isArray(packet.granted)) {
                    let hasError = false;
                    packet.granted.forEach((g, i) => {
                        if (typeof g === 'object') {
                            console.log(`   [${i}] Topic: ${g.topic || 'N/A'}, QoS: ${g.qos !== undefined ? g.qos : 'N/A'}`);
                        } else {
                            // Se granted √® un array di numeri (codici QoS)
                            // QoS 0-2 = successo, 128 = failure, 130+ = altri errori
                            if (g === 128) {
                                console.error(`   ‚ùå [${i}] ERRORE: QoS Code 128 = SOTTOSCRIZIONE RIFIUTATA!`);
                                hasError = true;
                            } else if (g >= 130) {
                                console.error(`   ‚ùå [${i}] ERRORE: QoS Code ${g} = Errore di sottoscrizione`);
                                hasError = true;
                            } else {
                                console.log(`   ‚úÖ [${i}] QoS Code: ${g} = Successo`);
                            }
                        }
                    });
                    
                    if (hasError) {
                        console.error('‚ùå PROBLEMA: Le sottoscrizioni sono state RIFIUTATE dal broker!');
                        console.error('‚ùå Possibili cause:');
                        console.error('   1. Limitazioni del piano gratuito HiveMQ Cloud');
                        console.error('   2. Problemi di autorizzazione/permessi');
                        console.error('   3. Formato topic non supportato');
                        console.error('');
                        console.error('üí° SOLUZIONE ALTERNATIVA:');
                        console.error('   Prova a usare un client MQTT desktop (MQTT.fx, MQTT Explorer)');
                        console.error('   per verificare se i dati arrivano comunque al broker.');
                        updateDebugInfo('SOTTOSCRIZIONI RIFIUTATE');
                    } else {
                        updateDebugInfo('SOTTOSCRIZIONI ATTIVE');
                    }
                } else if (packet.granted) {
                    console.log('   Granted (non array):', packet.granted);
                    updateDebugInfo('SOTTOSCRIZIONI ATTIVE');
                }
            }
        });

        function updateDashboard(data) {
            // Aggiorna GPS
            if (data.lat && data.lng && data.lat !== 0 && data.lng !== 0) {
                document.getElementById('latitude').textContent = data.lat.toFixed(6);
                document.getElementById('longitude').textContent = data.lng.toFixed(6);
        const newLatLng = L.latLng(data.lat, data.lng);
                
                // Aggiorna mappa
                if (!kartMarker) {
            kartMarker = L.marker(newLatLng).addTo(map);
            markerStartLatLng = newLatLng;
            markerTargetLatLng = newLatLng;
                } else {
            markerStartLatLng = kartMarker.getLatLng();
            markerTargetLatLng = newLatLng;
            startMarkerAnimation(data.speed);
                }
                
                // Aggiungi punto al tracciato (come nella dashboard principale)
                trackLine.push([data.lat, data.lng]);
                
                // Usa setLatLngs invece di rimuovere/ricreare (come nella dashboard principale)
                if (!trackPolyline) {
                    trackPolyline = L.polyline([], { color: '#00ff88', weight: 3 }).addTo(map);
                }
                trackPolyline.setLatLngs(trackLine);
                
                // fitBounds solo al primo punto (come nella dashboard principale - non ad ogni aggiornamento)
                if (trackLine.length === 1) {
                    map.setView([data.lat, data.lng], 16);
                }
            }

            // Aggiorna velocit√† e altitudine - MANTIENE VALORE PRECEDENTE SE NON ARRIVANO NUOVI DATI
            if (data.speed !== undefined) {
                cachedSpeed = data.speed;
            }
            if (data.alt !== undefined) {
                cachedAlt = data.alt;
            }
            if (data.satellites !== undefined) {
                cachedSatellites = data.satellites;
            }
            document.getElementById('speed').textContent = cachedSpeed !== null ? cachedSpeed.toFixed(1) + ' km/h' : '--';
            document.getElementById('altitude').textContent = cachedAlt !== null ? cachedAlt.toFixed(1) + ' m' : '--';
            document.getElementById('satellites').textContent = cachedSatellites !== null ? cachedSatellites : '--';
            // Tappeto status e coordinate - LOGICA IDENTICA ALLA DASHBOARD LOCALE
            // IMPORTANTE: Usa cache per evitare lampeggiare quando GPS oscilla
            // I valori del tappeto vengono aggiornati solo se sono "validi" (non null/undefined)
            // e vengono mantenuti in cache per evitare reset quando GPS perde segnale
            if (data.tappeto_created !== undefined && data.tappeto_created !== null) {
                cachedTappetoCreated = data.tappeto_created === true || data.tappeto_created === "true";
            }
            if (data.tappeto_mode !== undefined && data.tappeto_mode !== null) {
                cachedTappetoMode = data.tappeto_mode === true || data.tappeto_mode === "true";
            }
            if (data.tappeto_coordinates !== undefined && data.tappeto_coordinates !== null) {
                cachedTappetoCoordinates = data.tappeto_coordinates;
            }
            if (data.tappeto_center_lat !== undefined && data.tappeto_center_lat !== null && data.tappeto_center_lat !== 0) {
                cachedTappetoCenterLat = data.tappeto_center_lat;
            }
            if (data.tappeto_center_lng !== undefined && data.tappeto_center_lng !== null && data.tappeto_center_lng !== 0) {
                cachedTappetoCenterLng = data.tappeto_center_lng;
            }
            
            // Usa valori dalla cache (o dai dati se cache non disponibile)
            const tappetoStatusEl = document.getElementById('tappetoStatus');
            if (tappetoStatusEl && (cachedTappetoCreated !== null || cachedTappetoMode !== null)) {
                const tappetoCreated = cachedTappetoCreated !== null ? cachedTappetoCreated : (data.tappeto_created === true || data.tappeto_created === "true");
                const tappetoMode = cachedTappetoMode !== null ? cachedTappetoMode : (data.tappeto_mode === true || data.tappeto_mode === "true");
                tappetoStatusEl.textContent = tappetoCreated ? 'CREATO' : (tappetoMode ? 'IN ATTESA PARTENZA/ARRIVO' : 'IN ATTESA');
            }
            const tappetoCoordsEl = document.getElementById('tappetoCoords');
            if (tappetoCoordsEl && (cachedTappetoCoordinates !== null || data.tappeto_coordinates !== undefined)) {
                const coords = cachedTappetoCoordinates !== null ? cachedTappetoCoordinates : data.tappeto_coordinates;
                tappetoCoordsEl.textContent = coords + '/10';
            }
            const tappetoCenterEl = document.getElementById('tappetoCenter');
            if (tappetoCenterEl) {
                if (cachedTappetoCreated && cachedTappetoCenterLat && cachedTappetoCenterLng) {
                    tappetoCenterEl.textContent = cachedTappetoCenterLat.toFixed(4) + ',' + cachedTappetoCenterLng.toFixed(4);
                } else if (cachedTappetoCreated === false || (data.tappeto_created !== undefined && !data.tappeto_created)) {
                    tappetoCenterEl.textContent = '--';
                }
                // Se tappeto non creato o valori non disponibili, mantiene il valore precedente
            }

            // Aggiorna temperature gomme - MANTIENE VALORE PRECEDENTE SE NON ARRIVANO NUOVI DATI
            if (data.temp_ad !== undefined) {
                cachedTempAD = data.temp_ad;
            }
            if (data.temp_ax !== undefined) {
                cachedTempAX = data.temp_ax;
            }
            if (data.temp_pd !== undefined) {
                cachedTempPD = data.temp_pd;
            }
            if (data.temp_px !== undefined) {
                cachedTempPX = data.temp_px;
            }
            document.getElementById('tempAD').textContent = cachedTempAD !== null ? cachedTempAD.toFixed(1) + '¬∞C' : '--';
            document.getElementById('tempAX').textContent = cachedTempAX !== null ? cachedTempAX.toFixed(1) + '¬∞C' : '--';
            document.getElementById('tempPD').textContent = cachedTempPD !== null ? cachedTempPD.toFixed(1) + '¬∞C' : '--';
            document.getElementById('tempPX').textContent = cachedTempPX !== null ? cachedTempPX.toFixed(1) + '¬∞C' : '--';

            // Aggiorna temperature motore - MANTIENE VALORE PRECEDENTE SE NON ARRIVANO NUOVI DATI
            if (data.temp_motore !== undefined) {
                cachedTempMotore = data.temp_motore;
            }
            if (data.temp_acqua !== undefined) {
                cachedTempAcqua = data.temp_acqua;
            }
            if (data.temp_scarico !== undefined) {
                cachedTempScarico = data.temp_scarico;
            }
            if (data.temp_ambiente !== undefined) {
                cachedTempAmbiente = data.temp_ambiente;
            }
            document.getElementById('tempMotore').textContent = cachedTempMotore !== null ? cachedTempMotore.toFixed(1) + '¬∞C' : '--';
            document.getElementById('tempAcqua').textContent = cachedTempAcqua !== null ? cachedTempAcqua.toFixed(1) + '¬∞C' : '--';
            document.getElementById('tempScarico').textContent = cachedTempScarico !== null ? cachedTempScarico.toFixed(1) + '¬∞C' : '--';
            document.getElementById('tempAmbiente').textContent = cachedTempAmbiente !== null ? cachedTempAmbiente.toFixed(1) + '¬∞C' : '--';

            // Aggiorna cronometro - MANTIENE VALORE PRECEDENTE SE NON ARRIVANO NUOVI DATI
            if (data.cronometro_status !== undefined) {
                cachedCronometroStatus = data.cronometro_status;
            }
            if (data.cronometro_lap_time !== undefined) {
                cachedCronometroLapTime = data.cronometro_lap_time;
            }
            if (data.completed_giri !== undefined) {
                cachedCompletedGiri = data.completed_giri;
            }
            if (data.target_giri !== undefined) {
                cachedTargetGiri = data.target_giri;
            }
            if (data.lap_times !== undefined && Array.isArray(data.lap_times)) {
                cachedLapTimes = data.lap_times;
            }
            if (data.cronometro_last_lap_time !== undefined && data.cronometro_last_lap_time > 0) {
                cachedLastLapTime = data.cronometro_last_lap_time;
            }
            
            if (cachedCronometroStatus !== null) {
                document.getElementById('cronometroStatus').textContent = cachedCronometroStatus;
            }
            if (cachedCronometroLapTime !== null) {
                document.getElementById('cronometroLapTime').textContent = formatTime(cachedCronometroLapTime);
            }
            if (cachedLastLapTime !== null && cachedLastLapTime > 0) {
                const container = document.getElementById('lastLapTime');
                if (container) {
                    const formattedTime = formatTime(cachedLastLapTime);
                    container.innerHTML = '<div style="color:#ffaa00;font-weight:bold;text-align:center;padding:5px;background:rgba(255,170,0,0.2);border-radius:5px;margin:5px 0">Ultimo Giro: ' + formattedTime + '</div>';
                }
            }
            if (cachedCompletedGiri !== null) {
                document.getElementById('completedGiri').textContent = cachedCompletedGiri;
            }
            if (cachedTargetGiri !== null) {
                document.getElementById('targetGiri').textContent = cachedTargetGiri;
            }
            const lapTimesEl = document.getElementById('lapTimesList');
            if (lapTimesEl) {
                const lapTimes = cachedLapTimes || [];
                if (lapTimes.length === 0) {
                    lapTimesEl.innerHTML = '<div style="color:#ccc;text-align:center">Nessun giro completato</div>';
                } else {
                    let lapHtml = '';
                    lapTimes.forEach(function(time, index) {
                        const lapNumber = index + 1;
                        const formattedTime = formatTime(time);
                        lapHtml += '<div style="color:#00ff88;margin:2px 0;padding:2px 5px;background:rgba(0,255,136,0.1);border-radius:3px">' + lapNumber + ') Giro: ' + formattedTime + '</div>';
                    });
                    lapTimesEl.innerHTML = lapHtml;
                }
            }

            // Controllo se la gara √® finita
            const garaFinitaMessage = document.getElementById('garaFinitaMessage');
            const bestLapTimeDisplay = document.getElementById('bestLapTimeDisplay');
            const isGaraFinita = (data.redirectToFineGara === true || data.redirectToFineGara === "true") || 
                                 (cachedCompletedGiri !== null && cachedTargetGiri !== null && cachedCompletedGiri >= cachedTargetGiri);
            
            if (isGaraFinita && garaFinitaMessage && bestLapTimeDisplay) {
                // Calcola il miglior tempo dall'array lap_times
                const lapTimes = cachedLapTimes || [];
                let bestTime = null;
                if (lapTimes.length > 0) {
                    bestTime = Math.min(...lapTimes);
                }
                
                if (bestTime !== null && bestTime > 0) {
                    bestLapTimeDisplay.textContent = formatTime(bestTime);
                } else {
                    bestLapTimeDisplay.textContent = '00:00.000';
                }
                
                garaFinitaMessage.style.display = 'block';
            } else if (garaFinitaMessage) {
                garaFinitaMessage.style.display = 'none';
            }

            // Aggiorna IMU - MANTIENE VALORE PRECEDENTE SE NON ARRIVANO NUOVI DATI
            if (data.lsm_ax !== undefined) {
                cachedLsmAx = data.lsm_ax;
            }
            if (data.lsm_ay !== undefined) {
                cachedLsmAy = data.lsm_ay;
            }
            if (data.lsm_az !== undefined) {
                cachedLsmAz = data.lsm_az;
            }
            if (data.lsm_gz !== undefined) {
                cachedLsmGz = data.lsm_gz;
            }
            if (data.lsm_stato !== undefined) {
                cachedLsmStato = data.lsm_stato;
            }
            document.getElementById('lsm_ax').textContent = cachedLsmAx !== null ? cachedLsmAx.toFixed(2) : '0.00';
            document.getElementById('lsm_ay').textContent = cachedLsmAy !== null ? cachedLsmAy.toFixed(2) : '0.00';
            document.getElementById('lsm_az').textContent = cachedLsmAz !== null ? cachedLsmAz.toFixed(2) : '0.00';
            document.getElementById('lsm_gz').textContent = cachedLsmGz !== null ? cachedLsmGz.toFixed(2) : '0.00';
            document.getElementById('lsm_stato').textContent = cachedLsmStato !== null ? cachedLsmStato : 'Fermo';

            // Aggiorna distanze - MANTIENE VALORE PRECEDENTE SE NON ARRIVANO NUOVI DATI
            if (data.distance_lap !== undefined) {
                cachedDistanceLap = data.distance_lap;
            }
            document.getElementById('distanceLap').textContent = cachedDistanceLap !== null ? cachedDistanceLap.toFixed(0) + ' m' : '--';
        }

function startMarkerAnimation(speed) {
    if (!kartMarker || !markerStartLatLng || !markerTargetLatLng) return;
    if (markerAnimationId) {
        cancelAnimationFrame(markerAnimationId);
        markerAnimationId = null;
    }
    markerAnimationStart = performance.now();
    let duration = 1000;
    if (typeof speed === 'number' && speed > 1) {
        duration = 1000 * (LIVE_REFERENCE_SPEED / speed);
        duration = Math.max(LIVE_MIN_DURATION, Math.min(LIVE_MAX_DURATION, duration));
    }
    markerAnimationDuration = duration;
    markerAnimationId = requestAnimationFrame(animateMarkerFrame);
}

function animateMarkerFrame(now) {
    if (!markerStartLatLng || !markerTargetLatLng || !kartMarker) return;
    const elapsed = now - markerAnimationStart;
    const progress = Math.min(elapsed / markerAnimationDuration, 1);
    const lat = markerStartLatLng.lat + (markerTargetLatLng.lat - markerStartLatLng.lat) * progress;
    const lng = markerStartLatLng.lng + (markerTargetLatLng.lng - markerStartLatLng.lng) * progress;
    kartMarker.setLatLng([lat, lng]);
    if (progress < 1) {
        markerAnimationId = requestAnimationFrame(animateMarkerFrame);
    } else {
        markerAnimationId = null;
        markerStartLatLng = kartMarker.getLatLng();
    }
}

        function updateTelemetryStatus() {
            const el = document.getElementById('telemetryStatus');
            if (!el) return;

            if (!mqttConnectedFlag) {
                el.textContent = 'Telemetria non disponibile';
                el.style.color = '#ff6666';
                return;
            }

            if (lastTelemetryTime === 0) {
                el.textContent = 'In attesa dati telemetria';
                el.style.color = '#ffcc66';
                return;
            }

            const diff = Date.now() - lastTelemetryTime;
            if (diff > TELEMETRY_TIMEOUT) {
                el.textContent = 'Telemetria inattiva (invio disabilitato?)';
                el.style.color = '#ffcc66';
            } else {
                el.textContent = 'Telemetria attiva';
                el.style.color = '#00ff88';
            }
        }

        function formatTime(seconds) {
            if (!seconds) return '00:00.000';
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${mins.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;
        }
    </script>
</body>
</html>




